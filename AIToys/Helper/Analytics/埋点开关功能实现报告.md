# 埋点开关功能实现报告

## 功能概述

实现了基于用户"功能体验升级计划"权限的埋点开关功能，只有当用户同意该权限时，才会执行项目中的埋点上报。

## 实现方案

### 1. 埋点开关控制

**文件**: `AIToys/Helper/Analytics/AnalyticsManager.h`

```objc
/**
 * 设置埋点是否启用
 * @param enabled YES启用埋点，NO禁用埋点
 */
- (void)setAnalyticsEnabled:(BOOL)enabled;

/**
 * 获取埋点是否启用
 * @return YES已启用，NO已禁用
 */
- (BOOL)isAnalyticsEnabled;
```

**文件**: `AIToys/Helper/Analytics/AnalyticsManager.m`

```objc
- (void)setAnalyticsEnabled:(BOOL)enabled {
    [CoreArchive setBool:enabled key:KISAgreeImprovement];
}

- (BOOL)isAnalyticsEnabled {
    // 检查是否已经设置过，如果没有设置过则默认为YES
    NSString *value = [CoreArchive strForKey:KISAgreeImprovement];
    if (value == nil) {
        // 首次使用，默认启用埋点
        return YES;
    }
    return [CoreArchive boolForKey:KISAgreeImprovement];
}
```

### 2. 埋点上报拦截

在基础埋点上报方法中添加开关检查：

```objc
- (void)reportEvent:(EventLogModel *)eventModel 
         completion:(nullable void(^)(BOOL success, NSString * _Nullable message))completion {
    
    // 检查埋点是否启用
    if (![self isAnalyticsEnabled]) {
        if (completion) {
            completion(YES, @"埋点已禁用，跳过上报");
        }
        return;
    }
    
    // ... 原有的埋点上报逻辑
}
```

### 3. 用户权限页面集成

**文件**: `AIToys/Login/UserPermmitVC.m`

#### 3.1 数据加载时同步开关状态

```objc
- (void)loadDataWithKey:(NSString *)key {
    // ... API请求代码
    if([key isEqualToString:@"1"]){
        BOOL isEnabled = [weakSelf.model.propValue isEqualToString:@"1"];
        weakSelf.selcArr[0].isOn = isEnabled;
        // 同步埋点开关状态
        [[AnalyticsManager sharedManager] setAnalyticsEnabled:isEnabled];
    }
    // ...
}
```

#### 3.2 用户切换权限时同步开关状态

```objc
-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    self.selcArr[indexPath.row].isOn = !self.selcArr[indexPath.row].isOn;
    
    if(indexPath.row == 0){
        // 功能体验升级计划 - 控制埋点开关
        BOOL isEnabled = self.selcArr[indexPath.row].isOn;
        
        // 同步埋点开关状态
        [[AnalyticsManager sharedManager] setAnalyticsEnabled:isEnabled];
        
        // ... 保存到服务器的代码
    }
    // ...
}
```

## 功能特性

### 1. 权限绑定
- 埋点开关与"功能体验升级计划"(propKey="1")权限绑定
- 使用相同的存储key: `KISAgreeImprovement`
- 确保数据一致性

### 2. 默认行为
- **首次使用**: 默认启用埋点
- **用户明确关闭**: 禁用所有埋点上报
- **用户重新开启**: 恢复埋点上报

### 3. 拦截机制
- 在最底层的`reportEvent`方法中进行拦截
- 所有高级埋点方法都会经过这个检查
- 当埋点被禁用时，直接返回成功状态，避免错误

### 4. 性能优化
- 开关检查在方法开始处进行，避免不必要的数据处理
- 使用本地存储，避免每次都查询服务器

## 使用示例

### 1. 手动控制埋点开关

```objc
// 启用埋点
[[AnalyticsManager sharedManager] setAnalyticsEnabled:YES];

// 禁用埋点
[[AnalyticsManager sharedManager] setAnalyticsEnabled:NO];

// 检查状态
BOOL isEnabled = [[AnalyticsManager sharedManager] isAnalyticsEnabled];
NSLog(@"埋点状态: %@", isEnabled ? @"已启用" : @"已禁用");
```

### 2. 正常使用埋点（自动受开关控制）

```objc
// 这些埋点会自动受开关控制
[[AnalyticsManager sharedManager] reportClickBannerWithId:@"banner_001" name:@"活动"];
[[AnalyticsManager sharedManager] reportAddDeviceClickWithPid:@"device_001"];

// 当开关关闭时，上述调用会被自动跳过
```

## 数据流程

1. **用户进入权限页面** → 从服务器加载权限状态 → 同步埋点开关
2. **用户切换权限** → 更新本地开关状态 → 保存到服务器
3. **埋点上报** → 检查开关状态 → 决定是否执行上报

## 兼容性说明

### 1. 向后兼容
- 现有的埋点调用代码无需修改
- 开关功能是透明的，不影响现有逻辑

### 2. 默认行为
- 如果用户从未设置过权限，默认启用埋点
- 保证现有用户的埋点功能不受影响

### 3. 存储一致性
- 使用与权限页面相同的存储key
- 确保权限状态与埋点开关状态完全同步

## 测试验证

### 1. 功能测试
- [ ] 首次安装APP，埋点默认启用
- [ ] 关闭"功能体验升级计划"，埋点被禁用
- [ ] 重新开启"功能体验升级计划"，埋点恢复
- [ ] 权限页面状态与埋点开关状态保持同步

### 2. 性能测试
- [ ] 埋点开关检查不影响APP性能
- [ ] 禁用状态下埋点调用快速返回

### 3. 数据一致性测试
- [ ] 权限页面修改后，埋点开关立即生效
- [ ] APP重启后，开关状态正确恢复

## 注意事项

1. **隐私合规**: 严格按照用户授权执行埋点，符合隐私保护要求
2. **数据完整性**: 开关关闭期间的数据不会上报，需要考虑数据分析的连续性
3. **用户体验**: 开关切换立即生效，无需重启APP
4. **调试模式**: 开发阶段可以通过代码强制启用埋点进行调试
